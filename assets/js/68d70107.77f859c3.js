"use strict";(self.webpackChunkslatedb_website=self.webpackChunkslatedb_website||[]).push([[36],{8796:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"tutorials/checkpoint","title":"Checkpoint","description":"Creating a Checkpoint","source":"@site/docs/tutorials/checkpoint.md","sourceDirName":"tutorials","slug":"/tutorials/checkpoint","permalink":"/docs/tutorials/checkpoint","draft":false,"unlisted":false,"editUrl":"https://github.com/slatedb/slatedb-website/tree/main/docs/tutorials/checkpoint.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Checkpoint","sidebar_position":3},"sidebar":"docsSidebar","previous":{"title":"Connect SlateDB to S3","permalink":"/docs/tutorials/s3"},"next":{"title":"Connect SlateDB to S3 (Legacy)","permalink":"/docs/tutorials/s3-legacy"}}');var i=n(4848),c=n(8453);const s={title:"Checkpoint",sidebar_position:3},a=void 0,r={},l=[{value:"Creating a Checkpoint",id:"creating-a-checkpoint",level:2},{value:"Refreshing a Checkpoint",id:"refreshing-a-checkpoint",level:2},{value:"Deleting a Checkpoint",id:"deleting-a-checkpoint",level:2}];function h(e){const t={br:"br",code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"creating-a-checkpoint",children:"Creating a Checkpoint"}),"\n",(0,i.jsxs)(t.p,{children:["To create a checkpoint, use the ",(0,i.jsx)(t.code,{children:"create_checkpoint"})," function provided by SlateDB.",(0,i.jsx)(t.br,{}),"\n","This operation captures a consistent and durable view of the database state, anchored to a specific manifest version."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use slatedb::{\n    admin,\n    config::{DbOptions, CheckpointOptions},\n};\nuse object_store::memory::InMemory;\nuse object_store::path::Path;\nuse std::sync::Arc;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());\n\n    let path = Path::from("/my/test/db");\n\n    let db = slatedb::Db::open_with_opts(path.clone(), DbOptions::default(), object_store.clone())\n        .await?;\n\n\n    db.close().await?;\n\n    let result = admin::create_checkpoint(\n        path,\n        object_store.clone(),\n        &CheckpointOptions {\n            lifetime: Some(Duration::from_secs(3600)), // expires in 1 hour\n            ..Default::default()\n        },\n    )\n    .await?;\n\n    println!("Created checkpoint: ID = {}, Manifest = {}", result.id, result.manifest_id);\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"refreshing-a-checkpoint",children:"Refreshing a Checkpoint"}),"\n",(0,i.jsxs)(t.p,{children:["To extend the lifetime of an existing checkpoint, use ",(0,i.jsx)(t.code,{children:"Db::refresh_checkpoint"}),".\nThis updates the checkpoint\u2019s expiration time, ensuring that the referenced SSTs remain protected from garbage collection for the specified duration."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use slatedb::{\n    admin,\n    config::{DbOptions, CheckpointOptions},\n    Db,\n};\nuse object_store::memory::InMemory;\nuse object_store::path::Path;\nuse std::sync::Arc;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());\n    let path = Path::from("/tmp/refresh_checkpoint");\n\n    let db = Db::open_with_opts(path.clone(), DbOptions::default(), object_store.clone()).await?;\n    db.close().await?;\n\n    let result = admin::create_checkpoint(\n        path.clone(),\n        object_store.clone(),\n        &CheckpointOptions {\n            lifetime: Some(Duration::from_secs(300)),\n            ..Default::default()\n        },\n    )\n    .await?;\n\n    println!("Created checkpoint with 5 min lifetime: ID = {}", result.id);\n\n    Db::refresh_checkpoint(\n        &path,\n        object_store.clone(),\n        result.id,\n        Some(Duration::from_secs(7200)),\n    )\n    .await?;\n\n    println!("Checkpoint refreshed with extended 2-hour lifetime.");\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"deleting-a-checkpoint",children:"Deleting a Checkpoint"}),"\n",(0,i.jsxs)(t.p,{children:["To remove a checkpoint, use ",(0,i.jsx)(t.code,{children:"Db::delete_checkpoint"}),".\nThis deletes the checkpoint metadata from the manifest, allowing the garbage collector to eventually reclaim any unreferenced SST files associated with that checkpoint."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use slatedb::{\n    admin,\n    config::{DbOptions, CheckpointOptions},\n    Db,\n};\nuse object_store::memory::InMemory;\nuse object_store::path::Path;\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());\n    let path = Path::from("/tmp/delete_checkpoint");\n\n    let db = Db::open_with_opts(path.clone(), DbOptions::default(), object_store.clone()).await?;\n    db.close().await?;\n\n    let result = admin::create_checkpoint(\n        path.clone(),\n        object_store.clone(),\n        &CheckpointOptions::default(),\n    )\n    .await?;\n\n    println!("Created checkpoint: ID = {}", result.id);\n\n    Db::delete_checkpoint(&path, object_store.clone(), result.id).await?;\n    println!("Checkpoint deleted.");\n\n    Ok(())\n}\n'})})]})}function p(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},c=o.createContext(i);function s(e){const t=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(c.Provider,{value:t},e.children)}}}]);